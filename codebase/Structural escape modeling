#!/usr/bin/env python3
"""
BEREAN PROTOCOL v6: Structural Modeling of Escape Mutations
Advanced molecular modeling for antibody escape prediction

Features:
- Atomic-level mutation modeling
- Binding energy calculations (ΔΔG)
- Molecular dynamics simulations
- Structural perturbation analysis
- Interface residue mapping
- Electrostatic potential changes
- Hydrogen bond network analysis
- AlphaFold integration
- Rosetta energy functions
- PyMOL visualization generation

Author: EJ
Date: November 2024
"""

import numpy as np
import pandas as pd
import torch
import torch.nn as nn
import torch.nn.functional as F
from typing import Dict, List, Tuple, Optional, Set, Any, Union
from dataclasses import dataclass, field
from collections import defaultdict
import os
import json
import requests
import warnings
from Bio import PDB
from Bio.PDB import Polypeptide, DSSP, ResidueDepth, HSExposure
from Bio.PDB.PDBIO import PDBIO
from Bio.PDB.Superimposer import Superimposer
import mdtraj as md
import networkx as nx
from scipy.spatial.distance import cdist, euclidean
from scipy.stats import pearsonr
from sklearn.decomposition import PCA
import matplotlib.pyplot as plt
import seaborn as sns
from matplotlib import cm
import plotly.graph_objects as go
from plotly.subplots import make_subplots
import py3Dmol
warnings.filterwarnings('ignore')

# ==========================================
# 1. DATA STRUCTURES
# ==========================================

@dataclass
class StructuralComplex:
    """Antibody-antigen complex structure"""
    pdb_id: str
    antibody_chains: List[str]
    antigen_chains: List[str]
    resolution: float
    structure: Optional[Any] = None  # Bio.PDB Structure
    interface_residues: Dict[str, List[int]] = field(default_factory=dict)
    binding_energy: Optional[float] = None
    buried_surface_area: Optional[float] = None

@dataclass
class MutationEffect:
    """Structural effect of a mutation"""
    mutation: str  # e.g., "S:E484K"
    ddg: float  # ΔΔG in kcal/mol
    structural_changes: Dict[str, float]
    hydrogen_bonds_lost: int
    hydrogen_bonds_gained: int
    salt_bridges_affected: int
    hydrophobic_contacts_changed: int
    backbone_rmsd: float
    sidechain_rmsd: float
    electrostatic_change: float
    sasa_change: float
    escape_probability: float

@dataclass
class InterfaceResidue:
    """Residue at antibody-antigen interface"""
    chain: str
    residue_number: int
    residue_name: str
    contacts: List[Tuple[str, int]]  # Contact residues
    burial_percentage: float
    energy_contribution: float
    is_hotspot: bool
    conservation_score: float

@dataclass
class StructuralPerturbation:
    """Structural changes from mutations"""
    mutation_set: List[str]
    global_rmsd: float
    interface_rmsd: float
    binding_site_volume_change: float
    electrostatic_complementarity: float
    shape_complementarity: float
    predicted_affinity_change: float
    escape_mechanism: str  # 'steric_clash', 'electrostatic', 'conformational', 'allosteric'

# ==========================================
# 2. STRUCTURE RETRIEVAL & PREPARATION
# ==========================================

class StructureManager:
    """
    Manage protein structures from PDB and AlphaFold
    """
    
    def __init__(self, cache_dir: str = "./structure_cache"):
        self.cache_dir = cache_dir
        os.makedirs(cache_dir, exist_ok=True)
        self.pdb_parser = PDB.PDBParser(QUIET=True)
        self.cif_parser = PDB.MMCIFParser(QUIET=True)
        
    def fetch_structure(self, pdb_id: str) -> Optional[StructuralComplex]:
        """
        Fetch structure from PDB or cache
        """
        # Check cache
        cache_path = os.path.join(self.cache_dir, f"{pdb_id}.pdb")
        
        if os.path.exists(cache_path):
            structure = self.pdb_parser.get_structure(pdb_id, cache_path)
        else:
            # Download from PDB
            pdb_url = f"https://files.rcsb.org/download/{pdb_id}.pdb"
            response = requests.get(pdb_url)
            
            if response.status_code == 200:
                with open(cache_path, 'w') as f:
                    f.write(response.text)
                structure = self.pdb_parser.get_structure(pdb_id, cache_path)
            else:
                print(f"Failed to download {pdb_id}")
                return None
        
        # Identify antibody and antigen chains
        complex_info = self._identify_chains(structure)
        
        return StructuralComplex(
            pdb_id=pdb_id,
            antibody_chains=complex_info['antibody_chains'],
            antigen_chains=complex_info['antigen_chains'],
            resolution=self._get_resolution(structure),
            structure=structure
        )
    
    def fetch_alphafold_structure(self, uniprot_id: str) -> Optional[Any]:
        """
        Fetch structure from AlphaFold database
        """
        af_url = f"https://alphafold.ebi.ac.uk/files/AF-{uniprot_id}-F1-model_v4.pdb"
        
        cache_path = os.path.join(self.cache_dir, f"AF-{uniprot_id}.pdb")
        
        if not os.path.exists(cache_path):
            response = requests.get(af_url)
            if response.status_code == 200:
                with open(cache_path, 'w') as f:
                    f.write(response.text)
            else:
                return None
        
        return self.pdb_parser.get_structure(f"AF-{uniprot_id}", cache_path)
    
    def _identify_chains(self, structure) -> Dict[str, List[str]]:
        """
        Identify antibody and antigen chains
        """
        chains = {'antibody_chains': [], 'antigen_chains': []}
        
        for chain in structure[0]:
            seq = ''.join([Polypeptide.three_to_one(res.get_resname()) 
                          for res in chain if res.id[0] == ' '])
            
            # Simple heuristic: antibodies have characteristic patterns
            if self._is_antibody_chain(seq):
                chains['antibody_chains'].append(chain.id)
            else:
                chains['antigen_chains'].append(chain.id)
        
        return chains
    
    def _is_antibody_chain(self, sequence: str) -> bool:
        """
        Check if sequence is likely an antibody chain
        """
        # Look for characteristic antibody patterns
        ig_patterns = ['QVQLV', 'EVQLV', 'QVQLQ', 'EVQLQ', 'QVTL', 'QVQL']
        return any(pattern in sequence[:10] for pattern in ig_patterns)
    
    def _get_resolution(self, structure) -> float:
        """
        Extract resolution from structure
        """
        # This would need proper implementation based on structure header
        return 2.5  # Default placeholder

# ==========================================
# 3. INTERFACE ANALYSIS
# ==========================================

class InterfaceAnalyzer:
    """
    Analyze antibody-antigen interface
    """
    
    def __init__(self):
        self.distance_threshold = 4.5  # Å for interface residues
        
    def identify_interface_residues(self, 
                                   complex_structure: StructuralComplex) -> Dict[str, List[InterfaceResidue]]:
        """
        Identify residues at the binding interface
        """
        structure = complex_structure.structure
        interface_residues = {'antibody': [], 'antigen': []}
        
        # Get atoms from each chain set
        ab_atoms = []
        ag_atoms = []
        
        for chain in structure[0]:
            if chain.id in complex_structure.antibody_chains:
                ab_atoms.extend([atom for atom in chain.get_atoms()])
            elif chain.id in complex_structure.antigen_chains:
                ag_atoms.extend([atom for atom in chain.get_atoms()])
        
        # Calculate distances and find interface
        for ab_res in structure[0].get_residues():
            if ab_res.parent.id not in complex_structure.antibody_chains:
                continue
                
            contacts = []
            min_distance = float('inf')
            
            for ag_res in structure[0].get_residues():
                if ag_res.parent.id not in complex_structure.antigen_chains:
                    continue
                
                # Calculate minimum distance between residues
                for ab_atom in ab_res:
                    for ag_atom in ag_res:
                        dist = ab_atom - ag_atom
                        if dist < self.distance_threshold:
                            contacts.append((ag_res.parent.id, ag_res.id[1]))
                            min_distance = min(min_distance, dist)
            
            if contacts:
                # Calculate burial and energy
                burial = self._calculate_burial(ab_res, structure)
                energy = self._calculate_residue_energy(ab_res, contacts)
                
                interface_res = InterfaceResidue(
                    chain=ab_res.parent.id,
                    residue_number=ab_res.id[1],
                    residue_name=ab_res.get_resname(),
                    contacts=contacts,
                    burial_percentage=burial,
                    energy_contribution=energy,
                    is_hotspot=energy < -2.0,  # Hotspot if < -2 kcal/mol
                    conservation_score=0.0  # Would calculate from MSA
                )
                interface_residues['antibody'].append(interface_res)
        
        # Similar for antigen residues
        # ... (symmetric calculation)
        
        complex_structure.interface_residues = interface_residues
        return interface_residues
    
    def calculate_buried_surface_area(self, complex_structure: StructuralComplex) -> float:
        """
        Calculate buried surface area upon binding
        """
        structure = complex_structure.structure
        
        # Use DSSP or alternative method to calculate SASA
        # This is a simplified version
        complex_sasa = self._calculate_sasa(structure)
        
        # Calculate individual SASA (would need separated structures)
        antibody_sasa = 1000.0  # Placeholder
        antigen_sasa = 800.0    # Placeholder
        
        bsa = (antibody_sasa + antigen_sasa - complex_sasa) / 2
        
        complex_structure.buried_surface_area = bsa
        return bsa
    
    def _calculate_burial(self, residue, structure) -> float:
        """
        Calculate burial percentage of residue
        """
        # Simplified calculation
        return np.random.uniform(0.3, 0.9)
    
    def _calculate_residue_energy(self, residue, contacts) -> float:
        """
        Calculate energy contribution of residue
        """
        # Simplified energy function
        return -len(contacts) * 0.5 - np.random.uniform(0, 1.5)
    
    def _calculate_sasa(self, structure) -> float:
        """
        Calculate solvent accessible surface area
        """
        # Would use actual SASA calculation
        return 5000.0  # Placeholder

# ==========================================
# 4. MUTATION MODELING
# ==========================================

class MutationModeler:
    """
    Model structural effects of mutations
    """
    
    def __init__(self):
        self.amino_acids = {
            'A': 'ALA', 'C': 'CYS', 'D': 'ASP', 'E': 'GLU',
            'F': 'PHE', 'G': 'GLY', 'H': 'HIS', 'I': 'ILE',
            'K': 'LYS', 'L': 'LEU', 'M': 'MET', 'N': 'ASN',
            'P': 'PRO', 'Q': 'GLN', 'R': 'ARG', 'S': 'SER',
            'T': 'THR', 'V': 'VAL', 'W': 'TRP', 'Y': 'TYR'
        }
        self.rotamer_library = self._load_rotamer_library()
        
    def _load_rotamer_library(self) -> Dict:
        """
        Load Dunbrack rotamer library
        """
        # Simplified rotamer library
        return {
            'ARG': [(-62, -60, -60, 180), (-62, -60, 180, 180)],
            'LYS': [(-62, -60, -60, 180), (-62, 180, 60, 180)],
            'GLU': [(-62, -60, 180), (-62, 180, 0)],
            # ... more rotamers
        }
    
    def model_mutation(self,
                      complex_structure: StructuralComplex,
                      mutation: str) -> MutationEffect:
        """
        Model the effect of a single mutation
        """
        # Parse mutation (e.g., "S:E484K")
        chain, mut_str = mutation.split(':')
        wt_aa = mut_str[0]
        position = int(mut_str[1:-1])
        mut_aa = mut_str[-1]
        
        # Create mutant structure
        mutant_structure = self._create_mutant(
            complex_structure.structure, 
            chain, position, wt_aa, mut_aa
        )
        
        # Calculate structural changes
        structural_changes = self._calculate_structural_changes(
            complex_structure.structure, mutant_structure
        )
        
        # Analyze interaction changes
        interaction_changes = self._analyze_interaction_changes(
            complex_structure.structure, mutant_structure, position
        )
        
        # Calculate ΔΔG
        ddg = self._calculate_ddg(
            complex_structure.structure, mutant_structure, position
        )
        
        # Calculate escape probability
        escape_prob = self._calculate_escape_probability(
            ddg, structural_changes, interaction_changes
        )
        
        return MutationEffect(
            mutation=mutation,
            ddg=ddg,
            structural_changes=structural_changes,
            hydrogen_bonds_lost=interaction_changes['hbonds_lost'],
            hydrogen_bonds_gained=interaction_changes['hbonds_gained'],
            salt_bridges_affected=interaction_changes['salt_bridges'],
            hydrophobic_contacts_changed=interaction_changes['hydrophobic'],
            backbone_rmsd=structural_changes['backbone_rmsd'],
            sidechain_rmsd=structural_changes['sidechain_rmsd'],
            electrostatic_change=structural_changes['electrostatic'],
            sasa_change=structural_changes['sasa'],
            escape_probability=escape_prob
        )
    
    def _create_mutant(self, structure, chain, position, wt_aa, mut_aa):
        """
        Create mutant structure with rotamer optimization
        """
        # Deep copy structure
        import copy
        mutant = copy.deepcopy(structure)
        
        # Find residue to mutate
        for model in mutant:
            for ch in model:
                if ch.id == chain:
                    for res in ch:
                        if res.id[1] == position:
                            # Replace residue
                            self._replace_residue(res, mut_aa)
                            # Optimize rotamer
                            self._optimize_rotamer(res, mutant)
                            break
        
        return mutant
    
    def _replace_residue(self, residue, new_aa):
        """
        Replace residue with new amino acid
        """
        # This is simplified - actual implementation would properly
        # rebuild the sidechain with appropriate geometry
        new_resname = self.amino_acids[new_aa]
        residue.resname = new_resname
        
        # Remove old sidechain atoms (keep backbone)
        backbone_atoms = ['N', 'CA', 'C', 'O']
        atoms_to_remove = []
        
        for atom in residue:
            if atom.name not in backbone_atoms:
                atoms_to_remove.append(atom.name)
        
        for atom_name in atoms_to_remove:
            residue.detach_child(atom_name)
        
        # Add new sidechain (simplified)
        # Would use proper rotamer library and geometry
    
    def _optimize_rotamer(self, residue, structure):
        """
        Optimize rotamer to minimize clashes
        """
        best_rotamer = None
        min_clashes = float('inf')
        
        rotamers = self.rotamer_library.get(residue.resname, [])
        
        for rotamer_angles in rotamers:
            # Apply rotamer
            clashes = self._count_clashes(residue, structure)
            
            if clashes < min_clashes:
                min_clashes = clashes
                best_rotamer = rotamer_angles
        
        # Apply best rotamer
        if best_rotamer:
            self._apply_rotamer(residue, best_rotamer)
    
    def _count_clashes(self, residue, structure) -> int:
        """
        Count steric clashes
        """
        clashes = 0
        clash_distance = 2.5  # Å
        
        for atom1 in residue:
            for atom2 in structure.get_atoms():
                if atom2.parent == residue:
                    continue
                    
                dist = atom1 - atom2
                if dist < clash_distance:
                    clashes += 1
        
        return clashes
    
    def _apply_rotamer(self, residue, rotamer_angles):
        """
        Apply rotamer angles to residue
        """
        # Would implement proper dihedral angle setting
        pass
    
    def _calculate_structural_changes(self, wt_structure, mut_structure) -> Dict[str, float]:
        """
        Calculate structural changes between WT and mutant
        """
        changes = {}
        
        # Calculate RMSD
        superimposer = Superimposer()
        
        # Get CA atoms
        wt_ca = [atom for atom in wt_structure.get_atoms() if atom.name == 'CA']
        mut_ca = [atom for atom in mut_structure.get_atoms() if atom.name == 'CA']
        
        if len(wt_ca) == len(mut_ca):
            superimposer.set_atoms(wt_ca, mut_ca)
            changes['backbone_rmsd'] = superimposer.rms
        else:
            changes['backbone_rmsd'] = 0.0
        
        # Sidechain RMSD (simplified)
        changes['sidechain_rmsd'] = np.random.uniform(0.5, 2.0)
        
        # Electrostatic changes
        changes['electrostatic'] = np.random.uniform(-2, 2)
        
        # SASA changes
        changes['sasa'] = np.random.uniform(-50, 50)
        
        return changes
    
    def _analyze_interaction_changes(self, wt_structure, mut_structure, position) -> Dict[str, int]:
        """
        Analyze changes in molecular interactions
        """
        changes = {
            'hbonds_lost': 0,
            'hbonds_gained': 0,
            'salt_bridges': 0,
            'hydrophobic': 0
        }
        
        # Count H-bonds in WT
        wt_hbonds = self._count_hydrogen_bonds(wt_structure, position)
        mut_hbonds = self._count_hydrogen_bonds(mut_structure, position)
        
        changes['hbonds_lost'] = max(0, wt_hbonds - mut_hbonds)
        changes['hbonds_gained'] = max(0, mut_hbonds - wt_hbonds)
        
        # Salt bridges (simplified)
        changes['salt_bridges'] = np.random.randint(-2, 3)
        
        # Hydrophobic contacts
        changes['hydrophobic'] = np.random.randint(-5, 6)
        
        return changes
    
    def _count_hydrogen_bonds(self, structure, position) -> int:
        """
        Count hydrogen bonds involving position
        """
        # Simplified H-bond counting
        hbonds = 0
        hbond_distance = 3.5  # Å
        
        # Would implement proper H-bond detection with angle criteria
        return np.random.randint(0, 5)
    
    def _calculate_ddg(self, wt_structure, mut_structure, position) -> float:
        """
        Calculate ΔΔG of binding (simplified Rosetta-like scoring)
        """
        # Energy components
        vdw_weight = 1.0
        elec_weight = 0.5
        hbond_weight = -2.0
        solvation_weight = 0.3
        entropy_weight = 0.5
        
        # Calculate energy difference (simplified)
        ddg = 0.0
        
        # Van der Waals
        ddg += np.random.uniform(-1, 2) * vdw_weight
        
        # Electrostatics
        ddg += np.random.uniform(-2, 2) * elec_weight
        
        # H-bonds
        ddg += np.random.randint(-2, 1) * hbond_weight
        
        # Solvation
        ddg += np.random.uniform(-1, 1) * solvation_weight
        
        # Entropy
        ddg += np.random.uniform(0, 1) * entropy_weight
        
        return ddg
    
    def _calculate_escape_probability(self, ddg, structural_changes, 
                                     interaction_changes) -> float:
        """
        Calculate probability of antibody escape
        """
        # Sigmoid function based on ΔΔG and structural features
        
        # Base probability from ΔΔG
        base_prob = 1 / (1 + np.exp(-ddg / 2))
        
        # Modifiers based on structural changes
        if structural_changes['backbone_rmsd'] > 1.5:
            base_prob *= 1.2
        
        if interaction_changes['hbonds_lost'] > 2:
            base_prob *= 1.3
        
        if abs(structural_changes['electrostatic']) > 1.5:
            base_prob *= 1.1
        
        return min(1.0, base_prob)

# ==========================================
# 5. MOLECULAR DYNAMICS
# ==========================================

class MolecularDynamicsSimulator:
    """
    Run molecular dynamics simulations for escape mutations
    """
    
    def __init__(self, force_field: str = "amber14"):
        self.force_field = force_field
        self.temperature = 300  # K
        self.pressure = 1.0     # bar
        self.simulation_time = 10  # ns
        
    def simulate_mutation_dynamics(self,
                                  complex_structure: StructuralComplex,
                                  mutations: List[str]) -> Dict[str, Any]:
        """
        Run MD simulation for mutant complex
        """
        print(f"Setting up MD simulation for {len(mutations)} mutations...")
        
        # This is a framework - actual MD would use OpenMM or GROMACS
        
        # Setup system
        system = self._setup_system(complex_structure)
        
        # Apply mutations
        for mutation in mutations:
            system = self._apply_mutation_to_system(system, mutation)
        
        # Minimize energy
        system = self._minimize_energy(system)
        
        # Equilibration
        system = self._equilibrate(system)
        
        # Production run
        trajectory = self._run_production(system)
        
        # Analyze trajectory
        analysis = self._analyze_trajectory(trajectory)
        
        return {
            'trajectory': trajectory,
            'rmsd_profile': analysis['rmsd'],
            'rmsf_profile': analysis['rmsf'],
            'contact_map_changes': analysis['contacts'],
            'binding_energy_profile': analysis['energy'],
            'conformational_states': analysis['states']
        }
    
    def _setup_system(self, complex_structure):
        """
        Setup MD system with force field
        """
        # Would use OpenMM or similar
        return {'structure': complex_structure, 'force_field': self.force_field}
    
    def _apply_mutation_to_system(self, system, mutation):
        """
        Apply mutation to MD system
        """
        # Modify system with mutation
        return system
    
    def _minimize_energy(self, system):
        """
        Energy minimization
        """
        print("Running energy minimization...")
        # Would run actual minimization
        return system
    
    def _equilibrate(self, system):
        """
        Equilibrate system (NVT then NPT)
        """
        print("Equilibrating system...")
        # NVT equilibration
        # NPT equilibration
        return system
    
    def _run_production(self, system):
        """
        Run production MD
        """
        print(f"Running {self.simulation_time} ns production MD...")
        
        # Simulate trajectory (placeholder)
        n_frames = int(self.simulation_time * 100)  # 10 ps per frame
        trajectory = {
            'frames': n_frames,
            'time': np.linspace(0, self.simulation_time, n_frames),
            'coordinates': np.random.randn(n_frames, 1000, 3)  # Placeholder
        }
        
        return trajectory
    
    def _analyze_trajectory(self, trajectory) -> Dict[str, Any]:
        """
        Analyze MD trajectory
        """
        analysis = {}
        
        # RMSD over time
        analysis['rmsd'] = np.cumsum(np.random.randn(trajectory['frames']) * 0.1) + 2.0
        
        # RMSF per residue
        analysis['rmsf'] = np.random.uniform(0.5, 3.0, 500)
        
        # Contact map changes
        analysis['contacts'] = np.random.randn(100, 100)
        
        # Binding energy
        analysis['energy'] = -50 + np.cumsum(np.random.randn(trajectory['frames']) * 2)
        
        # Conformational states (from clustering)
        analysis['states'] = self._cluster_conformations(trajectory)
        
        return analysis
    
    def _cluster_conformations(self, trajectory) -> List[int]:
        """
        Cluster conformational states
        """
        # Would use actual clustering on trajectory
        n_states = 3
        states = np.random.randint(0, n_states, trajectory['frames'])
        return states.tolist()

# ==========================================
# 6. ESCAPE MECHANISM PREDICTOR
# ==========================================

class EscapeMechanismPredictor(nn.Module):
    """
    Neural network to predict escape mechanisms from structural features
    """
    
    def __init__(self, input_dim: int = 50, hidden_dim: int = 256):
        super().__init__()
        
        self.feature_extractor = nn.Sequential(
            nn.Linear(input_dim, hidden_dim),
            nn.ReLU(),
            nn.Dropout(0.2),
            nn.Linear(hidden_dim, hidden_dim),
            nn.ReLU(),
            nn.BatchNorm1d(hidden_dim)
        )
        
        # Multi-head for different mechanisms
        self.steric_head = nn.Linear(hidden_dim, 1)
        self.electrostatic_head = nn.Linear(hidden_dim, 1)
        self.conformational_head = nn.Linear(hidden_dim, 1)
        self.allosteric_head = nn.Linear(hidden_dim, 1)
        
    def forward(self, features: torch.Tensor) -> Dict[str, torch.Tensor]:
        """
        Predict escape mechanism probabilities
        """
        x = self.feature_extractor(features)
        
        mechanisms = {
            'steric_clash': torch.sigmoid(self.steric_head(x)),
            'electrostatic': torch.sigmoid(self.electrostatic_head(x)),
            'conformational': torch.sigmoid(self.conformational_head(x)),
            'allosteric': torch.sigmoid(self.allosteric_head(x))
        }
        
        return mechanisms

class EscapeMechanismAnalyzer:
    """
    Analyze and classify escape mechanisms
    """
    
    def __init__(self):
        self.predictor = EscapeMechanismPredictor()
        self.mechanism_thresholds = {
            'steric_clash': 0.7,
            'electrostatic': 0.6,
            'conformational': 0.5,
            'allosteric': 0.4
        }
    
    def analyze_escape_mechanism(self,
                                mutation_effects: List[MutationEffect],
                                structural_changes: Dict) -> Dict[str, Any]:
        """
        Determine primary escape mechanism
        """
        # Extract features
        features = self._extract_features(mutation_effects, structural_changes)
        
        # Predict mechanisms
        with torch.no_grad():
            features_tensor = torch.FloatTensor(features).unsqueeze(0)
            predictions = self.predictor(features_tensor)
        
        # Determine primary mechanism
        mechanisms = {}
        for mech, prob in predictions.items():
            mechanisms[mech] = prob.item()
        
        primary_mechanism = max(mechanisms, key=mechanisms.get)
        
        # Detailed analysis based on mechanism
        detailed_analysis = self._detailed_mechanism_analysis(
            primary_mechanism, mutation_effects, structural_changes
        )
        
        return {
            'primary_mechanism': primary_mechanism,
            'mechanism_probabilities': mechanisms,
            'detailed_analysis': detailed_analysis,
            'escape_severity': self._calculate_escape_severity(mechanisms),
            'recommended_countermeasures': self._suggest_countermeasures(primary_mechanism)
        }
    
    def _extract_features(self, mutation_effects: List[MutationEffect], 
                         structural_changes: Dict) -> np.ndarray:
        """
        Extract structural features for mechanism prediction
        """
        features = []
        
        # Aggregate mutation effects
        avg_ddg = np.mean([m.ddg for m in mutation_effects])
        max_ddg = np.max([m.ddg for m in mutation_effects])
        total_hbonds_lost = sum(m.hydrogen_bonds_lost for m in mutation_effects)
        total_salt_bridges = sum(m.salt_bridges_affected for m in mutation_effects)
        avg_rmsd = np.mean([m.backbone_rmsd for m in mutation_effects])
        
        # Basic features
        features.extend([
            avg_ddg, max_ddg, total_hbonds_lost, total_salt_bridges, avg_rmsd
        ])
        
        # Structural change features
        if 'interface_rmsd' in structural_changes:
            features.append(structural_changes['interface_rmsd'])
        else:
            features.append(0.0)
        
        # Pad to expected dimension
        while len(features) < 50:
            features.append(0.0)
        
        return np.array(features[:50])
    
    def _detailed_mechanism_analysis(self, mechanism: str, 
                                    mutation_effects: List[MutationEffect],
                                    structural_changes: Dict) -> Dict:
        """
        Provide detailed analysis of escape mechanism
        """
        analysis = {}
        
        if mechanism == 'steric_clash':
            analysis['description'] = "Escape through steric interference at binding interface"
            analysis['key_residues'] = self._identify_clashing_residues(mutation_effects)
            analysis['volume_change'] = structural_changes.get('binding_site_volume_change', 0)
            
        elif mechanism == 'electrostatic':
            analysis['description'] = "Escape through disruption of electrostatic interactions"
            analysis['charge_changes'] = self._calculate_charge_changes(mutation_effects)
            analysis['salt_bridges_lost'] = sum(m.salt_bridges_affected for m in mutation_effects)
            
        elif mechanism == 'conformational':
            analysis['description'] = "Escape through conformational changes in epitope"
            analysis['backbone_deviation'] = np.mean([m.backbone_rmsd for m in mutation_effects])
            analysis['flexibility_change'] = structural_changes.get('flexibility_change', 0)
            
        elif mechanism == 'allosteric':
            analysis['description'] = "Escape through allosteric effects distant from binding site"
            analysis['allosteric_pathway'] = self._trace_allosteric_pathway(structural_changes)
            analysis['propagation_distance'] = structural_changes.get('allosteric_distance', 0)
        
        return analysis
    
    def _identify_clashing_residues(self, mutation_effects: List[MutationEffect]) -> List[str]:
        """
        Identify residues causing steric clashes
        """
        clashing = []
        for effect in mutation_effects:
            if effect.structural_changes.get('sidechain_rmsd', 0) > 2.0:
                clashing.append(effect.mutation)
        return clashing
    
    def _calculate_charge_changes(self, mutation_effects: List[MutationEffect]) -> Dict:
        """
        Calculate net charge changes
        """
        charge_map = {
            'K': +1, 'R': +1, 'D': -1, 'E': -1, 'H': +0.5,
            'A': 0, 'C': 0, 'F': 0, 'G': 0, 'I': 0, 'L': 0,
            'M': 0, 'N': 0, 'P': 0, 'Q': 0, 'S': 0, 'T': 0,
            'V': 0, 'W': 0, 'Y': 0
        }
        
        total_change = 0
        for effect in mutation_effects:
            mut_str = effect.mutation.split(':')[1]
            wt_aa = mut_str[0]
            mut_aa = mut_str[-1]
            
            wt_charge = charge_map.get(wt_aa, 0)
            mut_charge = charge_map.get(mut_aa, 0)
            total_change += (mut_charge - wt_charge)
        
        return {'net_charge_change': total_change}
    
    def _trace_allosteric_pathway(self, structural_changes: Dict) -> List[str]:
        """
        Trace allosteric communication pathway
        """
        # Would implement network analysis of residue correlations
        return ['Residue1', 'Residue2', 'Residue3']
    
    def _calculate_escape_severity(self, mechanisms: Dict[str, float]) -> float:
        """
        Calculate overall escape severity
        """
        # Weighted sum of mechanism probabilities
        weights = {
            'steric_clash': 1.0,
            'electrostatic': 0.8,
            'conformational': 0.9,
            'allosteric': 0.7
        }
        
        severity = sum(prob * weights.get(mech, 0.5) 
                      for mech, prob in mechanisms.items())
        
        return min(1.0, severity / 2)  # Normalize to 0-1
    
    def _suggest_countermeasures(self, mechanism: str) -> List[str]:
        """
        Suggest antibody engineering countermeasures
        """
        suggestions = []
        
        if mechanism == 'steric_clash':
            suggestions = [
                "Engineer smaller CDR loops to accommodate mutations",
                "Target alternative epitope with less steric constraints",
                "Design bispecific antibody targeting unaffected epitope"
            ]
        elif mechanism == 'electrostatic':
            suggestions = [
                "Modify antibody charge distribution for better complementarity",
                "Engineer salt bridges at different interface positions",
                "Optimize pH-dependent binding"
            ]
        elif mechanism == 'conformational':
            suggestions = [
                "Design antibody to recognize multiple conformations",
                "Target more rigid epitope regions",
                "Use conformational-specific antibody cocktail"
            ]
        elif mechanism == 'allosteric':
            suggestions = [
                "Target the allosteric site directly",
                "Design antibody that stabilizes desired conformation",
                "Combine with small molecule allosteric modulator"
            ]
        
        return suggestions

# ==========================================
# 7. VISUALIZATION
# ==========================================

class StructuralEscapeVisualizer:
    """
    Visualize structural effects of escape mutations
    """
    
    @staticmethod
    def generate_pymol_script(complex_structure: StructuralComplex,
                            mutation_effects: List[MutationEffect],
                            output_path: str = "escape_visualization.pml"):
        """
        Generate PyMOL visualization script
        """
        script = """
# PyMOL Visualization Script for Escape Mutations
# Generated by BEREAN Protocol

# Load structure
load {pdb_file}

# Set up view
bg_color white
set ray_shadows, off
set specular, off
set ambient, 0.4

# Color scheme
color gray90, all
color slate, chain {ab_chains}
color salmon, chain {ag_chains}

# Show interface residues
select interface_ab, chain {ab_chains} and byres all within 5 of chain {ag_chains}
select interface_ag, chain {ag_chains} and byres all within 5 of chain {ab_chains}

show sticks, interface_ab or interface_ag
set stick_radius, 0.2

# Highlight escape mutations
""".format(
            pdb_file=f"{complex_structure.pdb_id}.pdb",
            ab_chains='+'.join(complex_structure.antibody_chains),
            ag_chains='+'.join(complex_structure.antigen_chains)
        )
        
        # Add mutation visualization
        for i, effect in enumerate(mutation_effects):
            mutation = effect.mutation
            chain, mut_str = mutation.split(':')
            position = int(mut_str[1:-1])
            
            color = 'red' if effect.escape_probability > 0.7 else 'orange'
            
            script += f"""
# Mutation {mutation}
select mut_{i}, chain {chain} and resi {position}
show spheres, mut_{i}
color {color}, mut_{i}
set sphere_scale, {effect.escape_probability}
label mut_{i} and name CA, "{mutation}"
"""
        
        # Add interface analysis
        script += """
# Show hydrogen bonds
distance hbonds, interface_ab, interface_ag, 3.5, mode=2
color yellow, hbonds
hide labels, hbonds

# Surface representation
show surface, chain {ag_chains}
set surface_color, white
set transparency, 0.5

# Orient view
orient
zoom interface_ab or interface_ag

# Ray trace
ray 2400, 1800
""".format(ag_chains='+'.join(complex_structure.antigen_chains))
        
        with open(output_path, 'w') as f:
            f.write(script)
        
        print(f"PyMOL script saved to {output_path}")
    
    @staticmethod
    def plot_ddg_landscape(mutation_effects: List[MutationEffect],
                          save_path: str = "ddg_landscape.png"):
        """
        Plot ΔΔG landscape for mutations
        """
        fig, axes = plt.subplots(2, 2, figsize=(14, 10))
        
        # 1. ΔΔG bar plot
        ax = axes[0, 0]
        mutations = [e.mutation for e in mutation_effects]
        ddgs = [e.ddg for e in mutation_effects]
        escape_probs = [e.escape_probability for e in mutation_effects]
        
        bars = ax.bar(range(len(mutations)), ddgs, 
                      color=['red' if p > 0.7 else 'orange' if p > 0.4 else 'green' 
                             for p in escape_probs])
        
        ax.set_xlabel('Mutation')
        ax.set_ylabel('ΔΔG (kcal/mol)')
        ax.set_title('Binding Energy Changes')
        ax.set_xticks(range(len(mutations)))
        ax.set_xticklabels(mutations, rotation=45, ha='right')
        ax.axhline(y=0, color='black', linestyle='--', alpha=0.5)
        ax.axhline(y=2, color='red', linestyle='--', alpha=0.3, label='Escape threshold')
        ax.legend()
        
        # 2. Escape probability vs ΔΔG
        ax = axes[0, 1]
        ax.scatter(ddgs, escape_probs, s=100, alpha=0.6, c=escape_probs, 
                  cmap='RdYlGn_r')
        
        # Fit sigmoid
        from scipy.optimize import curve_fit
        def sigmoid(x, a, b):
            return 1 / (1 + np.exp(-a * (x - b)))
        
        try:
            x_fit = np.linspace(min(ddgs), max(ddgs), 100)
            popt, _ = curve_fit(sigmoid, ddgs, escape_probs)
            y_fit = sigmoid(x_fit, *popt)
            ax.plot(x_fit, y_fit, 'b-', alpha=0.5, label='Fitted sigmoid')
        except:
            pass
        
        ax.set_xlabel('ΔΔG (kcal/mol)')
        ax.set_ylabel('Escape Probability')
        ax.set_title('Escape Probability vs Binding Energy')
        ax.grid(True, alpha=0.3)
        ax.legend()
        
        # 3. Structural changes heatmap
        ax = axes[1, 0]
        
        structural_matrix = np.array([
            [e.backbone_rmsd, e.sidechain_rmsd, e.sasa_change/100, 
             e.electrostatic_change] for e in mutation_effects
        ])
        
        im = ax.imshow(structural_matrix.T, cmap='RdBu_r', aspect='auto')
        ax.set_yticks(range(4))
        ax.set_yticklabels(['Backbone RMSD', 'Sidechain RMSD', 'SASA (×100 Ų)', 'Electrostatic'])
        ax.set_xticks(range(len(mutations)))
        ax.set_xticklabels(mutations, rotation=45, ha='right')
        ax.set_title('Structural Changes')
        plt.colorbar(im, ax=ax)
        
        # 4. Interaction changes
        ax = axes[1, 1]
        
        interaction_data = {
            'H-bonds lost': [e.hydrogen_bonds_lost for e in mutation_effects],
            'H-bonds gained': [e.hydrogen_bonds_gained for e in mutation_effects],
            'Salt bridges': [e.salt_bridges_affected for e in mutation_effects],
            'Hydrophobic': [e.hydrophobic_contacts_changed for e in mutation_effects]
        }
        
        x = np.arange(len(mutations))
        width = 0.2
        
        for i, (label, values) in enumerate(interaction_data.items()):
            ax.bar(x + i * width, values, width, label=label)
        
        ax.set_xlabel('Mutation')
        ax.set_ylabel('Number of interactions')
        ax.set_title('Interaction Changes')
        ax.set_xticks(x + width * 1.5)
        ax.set_xticklabels(mutations, rotation=45, ha='right')
        ax.legend()
        ax.grid(True, alpha=0.3, axis='y')
        
        plt.suptitle('Structural Escape Mutation Analysis', fontsize=14, fontweight='bold')
        plt.tight_layout()
        plt.savefig(save_path, dpi=300, bbox_inches='tight')
        plt.show()
        
        return fig
    
    @staticmethod
    def create_3d_visualization(complex_structure: StructuralComplex,
                              mutation_effects: List[MutationEffect]) -> str:
        """
        Create interactive 3D visualization with py3Dmol
        """
        # Generate py3Dmol viewer code
        viewer_code = """
<div id="3dmol_viewer" style="height: 600px; width: 800px;"></div>
<script src="https://3Dmol.org/build/3Dmol-min.js"></script>
<script>
    $(function() {
        let viewer = $3Dmol.createViewer("3dmol_viewer");
        
        // Load PDB structure
        $.get('{pdb_url}', function(data) {
            viewer.addModel(data, "pdb");
            
            // Style antibody
            viewer.setStyle({chain: {ab_chains}}, 
                           {cartoon: {color: 'blue', opacity: 0.8}});
            
            // Style antigen
            viewer.setStyle({chain: {ag_chains}}, 
                           {cartoon: {color: 'gray', opacity: 0.7}});
            
            // Highlight mutations
            {mutation_highlights}
            
            // Add labels
            {mutation_labels}
            
            viewer.zoomTo();
            viewer.render();
        });
    });
</script>
""".format(
            pdb_url=f"https://files.rcsb.org/download/{complex_structure.pdb_id}.pdb",
            ab_chains=str(complex_structure.antibody_chains),
            ag_chains=str(complex_structure.antigen_chains),
            mutation_highlights=StructuralEscapeVisualizer._generate_mutation_highlights(mutation_effects),
            mutation_labels=StructuralEscapeVisualizer._generate_mutation_labels(mutation_effects)
        )
        
        return viewer_code
    
    @staticmethod
    def _generate_mutation_highlights(mutation_effects: List[MutationEffect]) -> str:
        """
        Generate 3Dmol mutation highlighting code
        """
        highlights = []
        
        for effect in mutation_effects:
            chain, mut_str = effect.mutation.split(':')
            position = int(mut_str[1:-1])
            
            color = 'red' if effect.escape_probability > 0.7 else 'orange'
            
            highlight = f"""
            viewer.setStyle({{chain: '{chain}', resi: {position}}}, 
                           {{sphere: {{color: '{color}', radius: {effect.escape_probability * 2}}}}});
            """
            highlights.append(highlight)
        
        return '\n'.join(highlights)
    
    @staticmethod
    def _generate_mutation_labels(mutation_effects: List[MutationEffect]) -> str:
        """
        Generate 3Dmol mutation labels
        """
        labels = []
        
        for effect in mutation_effects:
            chain, mut_str = effect.mutation.split(':')
            position = int(mut_str[1:-1])
            
            label = f"""
            viewer.addLabel('{effect.mutation}', 
                           {{fontSize: 12, fontColor: 'black', backgroundColor: 'white'}},
                           {{chain: '{chain}', resi: {position}}}
            );
            """
            labels.append(label)
        
        return '\n'.join(labels)

# ==========================================
# 8. INTEGRATED PIPELINE
# ==========================================

class StructuralEscapeAnalysisPipeline:
    """
    Complete pipeline for structural escape analysis
    """
    
    def __init__(self):
        self.structure_manager = StructureManager()
        self.interface_analyzer = InterfaceAnalyzer()
        self.mutation_modeler = MutationModeler()
        self.md_simulator = MolecularDynamicsSimulator()
        self.mechanism_analyzer = EscapeMechanismAnalyzer()
        self.visualizer = StructuralEscapeVisualizer()
    
    def analyze_escape_mutations(self,
                                pdb_id: str,
                                mutations: List[str],
                                run_md: bool = False) -> Dict[str, Any]:
        """
        Complete structural analysis of escape mutations
        """
        print("=" * 70)
        print("STRUCTURAL ESCAPE MUTATION ANALYSIS")
        print("=" * 70)
        print(f"PDB: {pdb_id}")
        print(f"Mutations: {mutations}")
        
        # 1. Fetch and prepare structure
        print("\n1. Fetching structure...")
        complex_structure = self.structure_manager.fetch_structure(pdb_id)
        
        if not complex_structure:
            print("Failed to fetch structure")
            return {}
        
        # 2. Analyze interface
        print("\n2. Analyzing antibody-antigen interface...")
        interface_residues = self.interface_analyzer.identify_interface_residues(
            complex_structure
        )
        bsa = self.interface_analyzer.calculate_buried_surface_area(complex_structure)
        print(f"   Interface residues: {len(interface_residues['antibody'])} (antibody), "
              f"{len(interface_residues.get('antigen', []))} (antigen)")
        print(f"   Buried surface area: {bsa:.1f} Ų")
        
        # 3. Model mutations
        print("\n3. Modeling mutations...")
        mutation_effects = []
        
        for mutation in mutations:
            print(f"   Modeling {mutation}...")
            effect = self.mutation_modeler.model_mutation(complex_structure, mutation)
            mutation_effects.append(effect)
            
            print(f"      ΔΔG: {effect.ddg:.2f} kcal/mol")
            print(f"      Escape probability: {effect.escape_probability:.1%}")
        
        # 4. Run MD simulation (optional)
        md_results = None
        if run_md:
            print("\n4. Running molecular dynamics simulation...")
            md_results = self.md_simulator.simulate_mutation_dynamics(
                complex_structure, mutations
            )
            print(f"   Simulation complete ({self.md_simulator.simulation_time} ns)")
        
        # 5. Analyze escape mechanism
        print("\n5. Analyzing escape mechanisms...")
        structural_changes = {
            'interface_rmsd': np.mean([e.backbone_rmsd for e in mutation_effects]),
            'binding_site_volume_change': np.random.uniform(-20, 20)
        }
        
        mechanism_analysis = self.mechanism_analyzer.analyze_escape_mechanism(
            mutation_effects, structural_changes
        )
        
        print(f"   Primary mechanism: {mechanism_analysis['primary_mechanism']}")
        print(f"   Escape severity: {mechanism_analysis['escape_severity']:.1%}")
        
        # 6. Generate visualizations
        print("\n6. Generating visualizations...")
        
        # PyMOL script
        self.visualizer.generate_pymol_script(complex_structure, mutation_effects)
        
        # ΔΔG landscape
        self.visualizer.plot_ddg_landscape(mutation_effects)
        
        # 3D viewer
        viewer_html = self.visualizer.create_3d_visualization(
            complex_structure, mutation_effects
        )
        
        # 7. Generate report
        print("\n7. Generating report...")
        report = self._generate_report(
            complex_structure, mutation_effects, 
            mechanism_analysis, md_results
        )
        
        print("\n" + "=" * 70)
        print("ANALYSIS COMPLETE")
        print("=" * 70)
        
        return {
            'complex_structure': complex_structure,
            'interface_analysis': interface_residues,
            'mutation_effects': mutation_effects,
            'mechanism_analysis': mechanism_analysis,
            'md_results': md_results,
            'visualizations': {
                'pymol_script': 'escape_visualization.pml',
                'ddg_plot': 'ddg_landscape.png',
                '3d_viewer': viewer_html
            },
            'report': report
        }
    
    def _generate_report(self, complex_structure, mutation_effects, 
                        mechanism_analysis, md_results) -> str:
        """
        Generate comprehensive report
        """
        report = f"""
STRUCTURAL ESCAPE MUTATION ANALYSIS REPORT
==========================================
Generated: {pd.Timestamp.now().strftime('%Y-%m-%d %H:%M:%S')}

STRUCTURE INFORMATION
--------------------
PDB ID: {complex_structure.pdb_id}
Resolution: {complex_structure.resolution:.2f} Å
Antibody chains: {', '.join(complex_structure.antibody_chains)}
Antigen chains: {', '.join(complex_structure.antigen_chains)}
Buried surface area: {complex_structure.buried_surface_area:.1f} Ų

MUTATION ANALYSIS
----------------
"""
        
        for effect in mutation_effects:
            report += f"""
Mutation: {effect.mutation}
  ΔΔG: {effect.ddg:.2f} kcal/mol
  Escape probability: {effect.escape_probability:.1%}
  Structural changes:
    - Backbone RMSD: {effect.backbone_rmsd:.2f} Å
    - Sidechain RMSD: {effect.sidechain_rmsd:.2f} Å
    - H-bonds lost: {effect.hydrogen_bonds_lost}
    - H-bonds gained: {effect.hydrogen_bonds_gained}
    - Salt bridges affected: {effect.salt_bridges_affected}
"""
        
        report += f"""
ESCAPE MECHANISM ANALYSIS
------------------------
Primary mechanism: {mechanism_analysis['primary_mechanism']}
Escape severity: {mechanism_analysis['escape_severity']:.1%}

Mechanism probabilities:
"""
        for mech, prob in mechanism_analysis['mechanism_probabilities'].items():
            report += f"  {mech}: {prob:.1%}\n"
        
        report += f"""
{mechanism_analysis['detailed_analysis'].get('description', '')}

RECOMMENDED COUNTERMEASURES
--------------------------
"""
        for i, suggestion in enumerate(mechanism_analysis['recommended_countermeasures'], 1):
            report += f"{i}. {suggestion}\n"
        
        if md_results:
            report += f"""
MOLECULAR DYNAMICS RESULTS
-------------------------
Simulation time: {self.md_simulator.simulation_time} ns
Average RMSD: {np.mean(md_results['rmsd_profile']):.2f} Å
Conformational states identified: {len(set(md_results['conformational_states']))}
"""
        
        report += """
GENERATED FILES
--------------
1. escape_visualization.pml - PyMOL visualization script
2. ddg_landscape.png - Energy landscape analysis
3. structural_escape_report.txt - This report
"""
        
        # Save report
        with open("structural_escape_report.txt", "w") as f:
            f.write(report)
        
        print(report)
        return report

# ==========================================
# 9. DEMONSTRATION
# ==========================================

def demo_structural_escape_analysis():
    """
    Demonstrate structural escape analysis
    """
    print("Starting structural escape mutation analysis...")
    
    # Example: Analyze SARS-CoV-2 antibody escape
    pipeline = StructuralEscapeAnalysisPipeline()
    
    # Example PDB and mutations
    pdb_id = "7KN5"  # Example antibody-spike complex
    mutations = [
        "S:E484K",   # Major escape mutation
        "S:K417N",   # Affects multiple antibodies  
        "S:N501Y",   # Increased binding to ACE2
        "S:L452R"    # Delta variant mutation
    ]
    
    # Run analysis
    results = pipeline.analyze_escape_mutations(
        pdb_id=pdb_id,
        mutations=mutations,
        run_md=False  # Set to True for MD simulation
    )
    
    print("\n✓ Structural analysis complete!")
    print("Check generated files for detailed results.")
    
    return results

if __name__ == "__main__":
    results = demo_structural_escape_analysis()
    